from collections import Counter


from .parser import format_data

class HardEnsemble():
    """
        This class implements ensembling similar to voting classifier where 
        the output is the median output from the base models
    """
    def __init__(self, test_files, output_file_name, labelled_test_file, preference=-1):
        self.test_files = test_files
        self.output_file_name = output_file_name
        self.labelled_test_file = labelled_test_file
        self.preference = preference 
        self.test_files_to_data_mapper = {}
        self.ensemble_outputs = []
        self.parse_input_files()
        self.ensemble()
        for file_name in self.test_files:
            model_name = file_name.split("/")[-1].split('.')[0]
            print(f"{model_name} Accuracy : {self.compute_accuracy(self.test_files_to_data_mapper[file_name])}")
        
        print(f"Ensemble model's Accuracy : {self.compute_accuracy(self.ensemble_outputs)}")

    def parse_input_files(self):
        for file_name in self.test_files:
            sentences = format_data(file_name)
            self.test_files_to_data_mapper[file_name] = sentences

    def compute_accuracy(self, sentences):   
        correct_sen = format_data(self.labelled_test_file)         
        correct_total = 0
        total = 0
        for i in range(len(sentences)):  
            for predict, correct in zip(sentences[i], correct_sen[i]):
                    if predict[1] == correct[1]:
                        correct_total = correct_total + 1
                    total = total + 1
        acc = correct_total / total
        return acc

    def ensemble(self):
        
        outputs = []

        # iterate over each sentence 
        for i in range(len(self.test_files_to_data_mapper[self.test_files[0]])):  
            sentence_ouput = []
            # iterate over each word
            for j in range(len(self.test_files_to_data_mapper[self.test_files[0]][i])):
                x = ""
                y = []
                # iterate over the output generated by each model for each word
                for file_name in self.test_files:      
                    (x, predicted_output) = self.test_files_to_data_mapper[file_name][i][j]
                    y.append(predicted_output)

                ensemble_prediction = self.voting(x, y)
                sentence_ouput.append((x, ensemble_prediction))
            outputs.append(sentence_ouput)

        self.ensemble_outputs = outputs
        

    def voting(self, x, y):
        """
        We return the mode as the output of the ensemble 
        """
        data = Counter(y)
        if len(data) == 1:
            return data.most_common(1)[0][0]
        # two elements are equal 
        elif data.most_common(2)[0][0] == data.most_common(2)[1][0]:
            return y[self.preference]
        # only one mode element
        else:
            return data.most_common(1)[0][0]

    def generate_labelled_data(self):
        f = open(self.output_file_name, "w")
        for sentence in self.ensemble_outputs:
            for word, pos in sentence:
                f.write(f"{word} {pos}\n")
            f.write(f"\n")
        f.close()
